Overall:

For this assignment, our team developed a 2D simulation that uses a variety of modeling techniques, including a physics-based system, a particle system, and a cellular automata ruleset. The goal is to create an immersive night scene featuring fireworks, shooting stars, and a flammable cloth that dynamically reacts to its environment. Fireworks burst in colorful explosions, shooting stars streak across the sky, and the cloth ignites when exposed to fire, spreading flames according to specific heat-based interactions. To further enhance realism, we introduced wind, which interacts with the fireworks and burning cloth, creating a more dynamic and unpredictable simulation.

Each team member is responsible for designing and implementing a unique object within the simulation. The Firework class uses a physics-based approach to simulate explosive bursts, influenced by gravity and an internal spring force. The Star class functions as a particle system, creating falling stars that fade as they descend. The Cloth class implements a cellular automata model, allowing fire to spread naturally across its surface. Finally, the Wind class introduces varying intensities of air movement, affecting fire and embers while remaining independent of celestial elements like the shooting stars. Together, these components form an interactive and visually engaging simulation that captures the complexity of real-world motion and environmental forces.

To ensure a smooth integration process, we refined interactions between objects before finalizing the simulation. Our Firework class will include an extra interactive feature, allowing users to trigger fireworks through mouse and keyboard input. By combining physics, particles, and rules-based mechanics, we aim to create a compelling and dynamic simulation. One unexpected challenge was integrating the different classes together to ensure that the firework debris would ignite the cloth properly. We also modified various parameters to ensure the simulation ran smoothly without significant slowing due to too many particles.


Matthew Na (Firework and Debris Classes):

For my section of the assignment, I chose to create a physics-based simulation to create the visual effects of colorful fireworks. To do this, I made two classes, including the Debris class and the Firework class. The forces that will guide the individual firework objects include a gravitational force and a spring force that makes the debris oscillate in the x-direction as they fall. This makes the explosions appear dynamic and chaotic. This spring force is embedded in the individual Debris objects of the fireworks, creating a visual effect of the firework fizzling out. 

The Debris class uses a few arguments, including the x and y positions and a boolean that determines the shape of the debris, in order to initialize the debris objects. This ensures the user does not need to worry about manually setting velocity, acceleration, mass, angular velocity and color values. I chose to do this because my code will randomize these necessary values within appropriate ranges, allowing the debris to be generated with consistently effective results. While the arguments are limited for user input, I've integrated mouse and keyboard controls for the fireworks themselves. This class has numerous methods to create functionality and organize the code's structure. For example, the "update()" method will create the debris's movements, and the spring force will be added as the debris approach the end of their lifespan and begin to disappear. The "drawStar()" method creates a star shape using vertex values to allow for different debris types, and the "display()" method will apply the appropriate colors and create the square and star visuals. An "isDone()" method will track when the debris objects become fully transparent and are no longer active. 

The Firework class builds upon the Debris class by creating numerous debris objects at a specified point. The global variable "debrisCount" sets the number of debris objects to 20 as a default, but this could be modified by the user to change the firework's density. This class also uses limited arguments, only the x and y positions of the firework, to ensure the user only needs to use the mouse and keyboard commands as stated in the README. An "explode()" method will generate multiple debris objects with half being squares and half being stars. A "display()" method calls the methods of each debris object, applying the gravitational force, updating their movements and colors, and displaying them. Similarly, an "isDone()" method will return whether the firework has fully disappeared or not. This will ensure that there are never more than the specified maximum number of fireworks set by the "maxFireworks" global variable. Other global variables include the gravity force, spring and damping coefficients, allowing the user to change these parameters to affect the simulation as desired. 

As mentioned previously, for user interactivity, I've added mouse and keyboard controls that are specified in detail in the README file. In the main program file, a "mousePressed()" method will add a new firework in the mouse's position upon clicking, and a "keyPressed()" method will change the firework's color scheme from the default.

To make the firework objects visually appealing, I use a variety of colors on the debris to make them distinct. The user can use keyboard commands as specified in the README in order to toggle between three different color schemes. To create a unique visual appearance, the debris include small squares that spin randomly and stars that I've manually created using vertices and a separate method.


Ethan Harrah (Cloth and ClothThread classes):

My main implementation was the Cloth class. This class uses a network of cells with various states, and various rules on how the cells change as states change. The ClothThread class is used to represent each of these individual pieces of the thread. To show the state of the thread, color is used.

The Cloth class takes in a set of vertices, that will act as the bounds for the class. Originally, I planned on making it so that any convex polygon could be used in order to make the cloth boundaries, but that turned out to be a little bit too complicated, so there are still some remnants of that in the code for calculating the rectangular upper and lower bounds. Next there is the threadSize parameter. This decides the square side length of each of the ClothThread objects, and determines the amount of individual thread pieces there are, so it can be used as a variable to increase or decrease the fineness of the simulation. The heatTransferRate parameter determines how easily heat will transfer from one thread to another. The next parameters are essentially passdown parameters to the ClothThread objects, so each of these will be explained later, but they are: timeToBurn and timeToAsh.

To calculate the next step of how the Cloth will be simulated, the Cloth object loops through the entire array of threads, and determines what should happen to it based on the state. If the thread is not on fire, then the thread will increase its heat value according to proximity to threads currently on fire, as are stored in a threadsOnFire array. Once on fire, the thread will call burn(), then once fully burned it will call ash(). Upon completely ashing, the thread will be deleted from the whole threads array.

The ClothThread class first takes in a position of x and y, used for obvious reasons. The threadSize determines the size of the rendered square representing the thread, Then, as mentioned earlier, they also take in the timeToBurn. and timeToAsh. These variables will change how the simulation runs via the following methods: The methods burn() and ash() increment the times that the ClothThread currently have recorded for each respective action. Once the amount of burn or ash time exceeds the values passed in with timeToBurn and timeToAsh, respectively, then the thread changes into its next corresponding state.

In order to integrate with the FireWork class, I have the Cloth class light on fire whenever a Debris object collides with a clothThread at that x and y value. When the two different objects collide, the Debris object is also deleted.


Tiffany Nguyen (Star Class)

The intent of this animation was to create a particle system that simulates a plethora of shooting stars moving across the sky. I created a Star class that accepts the parameters x, y which indicates the starting position of the star. The x and y values are randomized in the main code to spawn the stars within the constraints of the screen size. The class also contains the constructor r, which is the radius of the star. This is also randomized from a value of 5 to 7 to add variation in the size of the stars. The Star class also has the variables opacity, vx, vy, and g. The Star class contains 2 methods: display() and applyForces().

The display() function displays the star as an ellipse that uses the x, y, r variables. The star changes appearance as it trails across the sky, decreasing in both size and opacity. The applyForces() function applies the force of gravity by increasing vy by g to increase the velocity to make the star appear to be going in an increasingly downward motion. x and y also get incremented by vx and vy to increment the position of x and y forward and down. vy is randomized in order to add variation to the curve in which the star moves. In the main code, stars are continuously added to an ArrayList under the condition that random(1) <= 0.1. There is a loop that loops through the ArrayList. This allows the stars to appear repeatedly and controls the frequency of the stars appearing on the screen.


Jim Duong (Wind Class):

I developed a Wind class to introduce dynamic environmental effects into our simulation. This class adds realism by applying smooth, shifting wind forces to firework debris and subtly influencing shooting stars, creating more natural and unpredictable motion.

The class uses two parameters: maxWindSpeed (which defines the strongest possible wind) and transitionRate (which controls how smoothly the wind changes). Internally, the class tracks a currentWindSpeed and gradually transitions it toward a targetWindSpeed, with random intervals of change to keep the effect varied and lifelike.

The main functionality is split into two methods: update() gradually shifts wind speed toward the target, while applyTo() applies horizontal wind force to objects. For debris, the force is scaled based on wind speed and inversely related to massâ€”lighter particles are pushed more strongly.

I integrated the wind system by updating it each frame and applying it to debris and stars in the main draw loop. The effect is most visible on debris, which can be blown dramatically off course during gusts, enhancing visual complexity.


