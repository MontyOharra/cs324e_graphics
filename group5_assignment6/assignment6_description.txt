Matthew (Firework and Debris Classes):

For my section of the assignment, I chose to create a physics-based simulation to create the visual effects of colorful fireworks. To do this, I made two classes, including the Debris class and the Firework class. The forces that will guide the individual firework objects include a gravitational force and a spring force that makes the debris oscillate in the x-direction as they fall. This makes the explosions appear dynamic and chaotic. This spring force is embedded in the individual Debris objects of the fireworks, creating a visual effect of the firework fizzling out. 

The Debris class uses a few arguments, including the x and y positions and a boolean that determines the shape of the debris, in order to initialize the debris objects. This ensures the user does not need to worry about manually setting velocity, acceleration, mass, angular velocity and color values. I chose to do this because my code will randomize these necessary values within appropriate ranges, allowing the debris to be generated with consistently effective results. While the arguments are limited for user input, I've integrated mouse and keyboard controls for the fireworks themselves. This class has numerous methods to create functionality and organize the code's structure. For example, the "update()" method will create the debris's movements, and the spring force will be added as the debris approach the end of their lifespan and begin to disappear. The "drawStar()" method creates a star shape using vertex values to allow for different debris types, and the "display()" method will apply the appropriate colors and create the square and star visuals. An "isDone()" method will track when the debris objects become fully transparent and are no longer active. 

The Firework class builds upon the Debris class by creating numerous debris objects at a specified point. The global variable "debrisCount" sets the number of debris objects to 20 as a default, but this could be modified by the user to change the firework's density. This class also uses limited arguments, only the x and y positions of the firework, to ensure the user only needs to use the mouse and keyboard commands as stated in the README. An "explode()" method will generate multiple debris objects with half being squares and half being stars. A "display()" method calls the methods of each debris object, applying the gravitational force, updating their movements and colors, and displaying them. Similarly, an "isDone()" method will return whether the firework has fully disappeared or not. This will ensure that there are never more than the specified maximum number of fireworks set by the "maxFireworks" global variable. Other global variables include the gravity force, spring and damping coefficients, allowing the user to change these parameters to affect the simulation as desired. 

As mentioned previously, for user interactivity, I've added mouse and keyboard controls that are specified in detail in the README file. In the main program file, a "mousePressed()" method will add a new firework in the mouse's position upon clicking, and a "keyPressed()" method will change the firework's color scheme from the default.

To make the firework objects visually appealing, I use a variety of colors on the debris to make them distinct. The user can use keyboard commands as specified in the README in order to toggle between three different color schemes. To create a unique visual appearance, the debris include small squares that spin randomly and stars that I've manually created using vertices and a separate method.

Ethan (Cloth and ClothThread classes):

My main implementation was the Cloth class. This class uses a network of cells with various states, and various rules on how the cells change as states change. The ClothThread class is used to represent each of these individual pieces of the thread. To show the state of the thread, color is used.

The Cloth class takes in a set of vertices, that will act as the bounds for the class. Originally, I planned on making it so that any convex polygon could be used in order to make the cloth boundaries, but that turned out to be a little bit too complicated, so there are still some remnants of that in the code for calculating the rectangular upper and lower bounds. Next there is the threadSize parameter. This decides the square side length of each of the ClothThread objects, and determines the amount of individual thread pieces there are, so it can be used as a variable to increase or decrease the fineness of the simulation. The heatTransferRate parameter determines how easily heat will transfer from one thread to another. The next parameters are essentially passdown parameters to the ClothThread objects, so each of these will be explained later, but they are: timeToBurn and timeToAsh.

To calculate the next step of how the Cloth will be simulated, the Cloth object loops through the entire array of threads, and determines what should happen to it based on the state. If the thread is not on fire, then the thread will increase its heat value according to proximity to threads currently on fire, as are stored in a threadsOnFire array. Once on fire, the thread will call burn(), then once fully burned it will call ash(). Upon completely ashing, the thread will be deleted from the whole threads array.

The ClothThread class first takes in a position of x and y, used for obvious reasons. The threadSize determines the size of the rendered square representing the thread, Then, as mentioned earlier, they also take in the timeToBurn. and timeToAsh. These variables will change how the simulation runs via the following methods: The methods burn() and ash() increment the times that the ClothThread currently have recorded for each respective action. Once the amount of burn or ash time exceeds the values passed in with timeToBurn and timeToAsh, respectively, then the thread changes into its next corresponding state.

In order to integrate with the FireWork class, I have the Cloth class light on fire whenever a Debris object collides with a clothThread at that x and y value. When the two different objects collide, the Debris object is also deleted.
